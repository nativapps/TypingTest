

<body onload="addWords()">

<div class="main_wrapper">
  <section class="test">
    <div class="content_test">
      <h3>Typing test Name</h3>
      
        <div id="word-section">
            <div class="waiting">
            </div>
        </div>
        
        <div id="type-section">
          <textarea id="typebox" rows="2" type="text" class="input_test" placeholder="Click or tap here and start typing!" tabindex="1" autofocus onkeyup="typingTest(event)"/>
          </textarea>
        </div>
    </div>
    
      <aside>
      <h5>Time left</h5>
      <div id="timer" class="input_test_aside"><span id="showTime">0:00</span></div>
         <!-- <input class="input_test_aside" type="text" placeholder="1:00" > -->

      <h5>Typing Speed</h5>

      <p>WPM</p>
      <input class="input_test_aside" id = "wpm" type="text">

      <p>Mistyped words</p>
      <!--<input class="input_test_aside" type="text" placeholder="0" >-->
      <input class="input_test_aside" id="count_incorrect" disabled><br>
    <!-- <a href="#" class="button button_line input_aside_cancel">CANCEL</a> -->

    </aside>
</div>
    
  <input id="tiempo" value="<%= @time %>" style="display: none">

  <input id="text_test" value="<%= @test.text_test %>" style="display: none">





  <section>
    <div>
      <%#= form_for @report, :url => { :controller => "report", :action => "create" }, :html => {:method => :post} do |r| %>
      <%#= form_for @report, :url => report_path, :html => { :method => :post } %>  
        <input id="count_typed" " style="display: none"><%# r.field disabled %><br>
        <input id="count_correct" disabled " style="display: none"><br>
        <input id="count_incorrect" disabled " style="display: none"><br>
        <input id="total_word" disabled " style="display: none"><br>

        <br>

        <input id="accuracy" disabled " style="display: none"><br>
        <input id="wpm" disabled " style="display: none"><br>
      <%# end %>
    </div>
    <!--<button>
      Enviar y Finalizar
    </button>-->
  </section>
  
  
  <script type="text/javascript" data-turbolinks-eval=false>
  // jQuery like selection of elements.
  window.$ = document.querySelectorAll.bind(document);
  
  // Changes for  Firefox
  if (navigator.userAgent.match(/firefox/i)) {
      // Unicode font sizes
      let ffBtn = "font-weight: normal; font-size: 2em; margin-left: 0.3em;";
      $("#restart-symbol")[0].setAttribute("style", ffBtn);
  
      let ffwait = "line-height: 1em; font-size: 4em;";
      $(".waiting")[0].setAttribute("style", ffwait);
  }
  
  /////////////////////////////////////////
  
  // Sorted list of the 500 most common English words.
  //let wordList = ["the", "name", "of", "very", "to", "through", "and", "just", "a", "form", "in", "much", "is", "great", "it", "think", "you", "say", "that", "help", "he", "low", "was", "line", "for", "before", "on", "turn", "are", "cause", "with", "same", "as", "mean", "I", "differ", "his", "move", "they", "right", "be", "boy", "at", "old", "one", "too", "have", "does", "this", "tell", "from", "sentence", "or", "set", "had", "three", "by", "want", "hot", "air", "but", "well", "some", "also", "what", "play", "there", "small", "we", "end", "can", "put", "out", "home", "other", "read", "were", "hand", "all", "port", "your", "large", "when", "spell", "up", "add", "use", "even", "word", "land", "how", "here", "said", "must", "an", "big", "each", "high", "she", "such", "which", "follow", "do", "act", "their", "why", "time", "ask", "if", "men", "will", "change", "way", "went", "about", "light", "many", "kind", "then", "off", "them", "need", "would", "house", "write", "picture", "like", "try", "so", "us", "these", "again", "her", "animal", "long", "point", "make", "mother", "thing", "world", "see", "near", "him", "build", "two", "self", "has", "earth", "look", "father", "more", "head", "day", "stand", "could", "own", "go", "page", "come", "should", "did", "country", "my", "found", "sound", "answer", "no", "school", "most", "grow", "number", "study", "who", "still", "over", "learn", "know", "plant", "water", "cover", "than", "food", "call", "sun", "first", "four", "people", "thought", "may", "let", "down", "keep", "side", "eye", "been", "never", "now", "last", "find", "door", "any", "between", "new", "city", "work", "tree", "part", "cross", "take", "since", "get", "hard", "place", "start", "made", "might", "live", "story", "where", "saw", "after", "far", "back", "sea", "little", "draw", "only", "left", "round", "late", "man", "run", "year", "don't", "came", "while", "show", "press", "every", "close", "good", "night", "me", "real", "give", "life", "our", "few", "under", "stop", "open", "ten", "seem", "simple", "together", "several", "next", "vowel", "white", "toward", "children", "war", "begin", "lay", "got", "against", "walk", "pattern", "example", "slow", "ease", "center", "paper", "love", "often", "person", "always", "money", "music", "serve", "those", "appear", "both", "road", "mark", "map", "book", "science", "letter", "rule", "until", "govern", "mile", "pull", "river", "cold", "car", "notice", "feet", "voice", "care", "fall", "second", "power", "group", "town", "carry", "fine", "took", "certain", "rain", "fly", "eat", "unit", "room", "lead", "friend", "cry", "began", "dark", "idea", "machine", "fish", "note", "mountain", "wait", "north", "plan", "once", "figure", "base", "star", "hear", "box", "horse", "noun", "cut", "field", "sure", "rest", "watch", "correct", "color", "able", "face", "pound", "wood", "done", "main", "beauty", "enough", "drive", "plain", "stood", "girl", "contain", "usual", "front", "young", "teach", "ready", "week", "above", "final", "ever", "gave", "red", "green", "list", "oh", "though", "quick", "feel", "develop", "talk", "sleep", "bird", "warm", "soon", "free", "body", "minute", "dog", "strong", "family", "special", "direct", "mind", "pose", "behind", "leave", "clear", "song", "tail", "measure", "produce", "state", "fact", "product", "street", "black", "inch", "short", "lot", "numeral", "nothing", "class", "course", "wind", "stay", "question", "wheel", "happen", "full", "complete", "force", "ship", "blue", "area", "object", "half", "decide", "rock", "surface", "order", "deep", "fire", "moon", "south", "island", "problem", "foot", "piece", "yet", "told", "busy", "knew", "test", "pass", "record", "farm", "boat", "top", "common", "whole", "gold", "king", "possible", "size", "plane", "heard", "age", "best", "dry", "hour", "wonder", "better", "laugh", "true", "thousand", "during", "ago", "hundred", "ran", "am", "check", "remember", "game", "step", "shape", "early", "yes", "hold", "hot", "west", "miss", "ground", "brought", "interest", "heat", "reach", "snow", "fast", "bed", "five", "bring", "sing", "sit", "listen", "perhaps", "six", "fill", "table", "east", "travel", "weight", "less", "language", "morning", "among"];
  //////////////////////////////////////////
  
  // Knuth-Fisher-Yates Shuffle
  // http://bost.ocks.org/mike/shuffle/
  function shuffle(array) {
      let m = array.length,
          t,
          i;
      // While there remain elements to shuffle…
      while (m) {
          // Pick a remaining element…
          i = Math.floor(Math.random() * m--);
          //i = m--;
          // And swap it with the current element.
          t = array[m];
          array[m] = array[i];
          array[i] = t;
      }
      return array;
  }
  
  // Add words to word-section
  
  function addWords() {
      // clear existing word-section
      let wordSection = $("#word-section")[0];
      wordSection.innerHTML = "";
      $("#typebox")[0].value = "";
  
      for (let i = wordList.length - 1; i >= 0; i--) {
          //let words = shuffle(wordList);  //disable the random word
          let words = wordList.reverse();;
          let wordSpan = `<span>${words[i]}</span>`;
          wordSection.innerHTML += wordSpan ;
      }
      // mark first word as current-word
      wordSection.firstChild.classList.add("current-word");

      // mark last word with magic-box
      // let magicBox = document.createElement("DIV");
      // magicBox.classList.add("magic-box");
      // wordSection.appendChild(magicBox);
  }
  
  //////////////////////////////////////////
  
  // Word Colors
  let colorCurrentWord = "#dddddd";
  let colorCorrectWord = "#93C572";
  let colorIncorrectWord = "#e50000";
  
  // Word Count and other data.
  let text_test = document.getElementById("text_test").value.replace(/[# ]/g, "++").split("++");

  let wordList = text_test; //["Hola", "Esto,", "funciona"];
  let tiempo = parseInt(document.getElementById("tiempo").value);
  let seconds = tiempo;
  let timePad = seconds < 10 ? "0" + seconds : seconds;
  let minutes = Math.floor(timePad/60);
  let second = Math.floor(timePad % 3600 % 60);
  let showTime = minutes + ":" + ((second < 10) ? "0" + second : second);
  let segundos = 0;
  document.getElementById("showTime").innerHTML = showTime;
  
  let timeInput = showTime;
  
  let wordData = {
    seconds: seconds,
    correct: 0,
    incorrect: 0,
    total: 0,
    typed: 0
  };
  
  //////////////////////////////////////////
  // Initial implementation notes:
  // next word on <space>, if empty, then set value=""
  // after <space> if value == current-word, mark as correct-word
  // else, mark as incorrect-word
  // if value.length != current-word[:value.length], mark as incorrect-word
  // else, mark as current-word
  //////////////////////////////////////////
  

  
  
  function checkIt(currentWord) {
      // how much we have of the current word.
      let current = $(".current-word")[0];
      let currentSubstring = current.innerHTML.substring(0, current.innerHTML.length);
      // check if we have any typing errors
      if (currentWord != currentSubstring) 
          return false;
       else 
          return true;
  }
  
  
  function submitWord(word) {
      // update current-word and
      // keep track of correct & incorrect words
      let current = $(".current-word")[0];

      if (checkIt(word)) {
          //console.log("Correcta ->*"+word.value);
          current.classList.remove("current-word", "incorrect-word-c");
          current.classList.add("correct-word-c");
          wordData.correct += 1;
          document.getElementById("count_correct").value = wordData.correct;
      } else {
         //console.log("Incorrecta ->*"+word.value);
          current.classList.remove("current-word", "incorrect-word-bg");
          current.classList.add("incorrect-word-c");
          wordData.incorrect += 1;
          document.getElementById("count_incorrect").value = wordData.incorrect;
      }
      // update wordData
      wordData.total = wordData.correct + wordData.incorrect;
      document.getElementById("total_word").value = wordData.total;
  
      // make the next word the new current-word.
      current.nextSibling.classList.add("current-word");
      typed_char=0; // SPACE reset to zero
      submitted_words++;
  }

  function goBack(word){
      // update current-word and
      // keep track of correct & incorrect words
      let current = $(".current-word")[0].previousSibling;
      //current.classList.remove("incorrect-word-c", "incorrect-word-bg", "correct-word-bg");
      if (current.classList.value == "correct-word-c") { 
          current.classList.remove("correct-word-c");
          current.classList.add("current-word");
          wordData.correct -= 1;
          document.getElementById("count_correct").value = wordData.correct;
      } else if(current.classList.value == "incorrect-word-c"){
          current.classList.remove("incorrect-word-c", "incorrect-word-bg");
          current.classList.add("current-word");
          wordData.incorrect -= 1;
          document.getElementById("count_incorrect").value = wordData.incorrect;
      }
      // update wordData
      wordData.total = wordData.correct + wordData.incorrect;
      document.getElementById("total_word").value = wordData.total;
  
      // make the next word the new current-word.
      current.classList.add("current-word");
      current.nextSibling.classList.remove("current-word");
  }
  
  function clearLine(sign) { // sign determina si sube o baja el scroll del cuadro de texto. Depende de si viene de SPACE o BACKSPACE
      // remove past words once you get to the next line
      let wordSection = $("#word-section")[0];
      let current = $(".current-word")[0]; // second line (first word)
      let previous = current.previousSibling; // first line (last word)
      console.log("offSet current=>"+current.offsetTop+" previous=>"+previous.offsetTop+"sign=>"+sign)
      if (current.offsetTop > previous.offsetTop)
           wordSection.scrollTop = wordSection.scrollTop + (sign*30);

  }
  
  function isTimer(seconds, timeInput) {
      // BUG: page refresh with keyboard triggers onkeyup and starts timer
      // Use restart button to reset timer
  
      let time = seconds;
      let timeInput2 = timeInput;
      // only set timer once
      let one = $("#timer > span")[0].innerHTML;
      if (one == timeInput2) {
          let typingTimer = setInterval(() => {
              if (time <= 0) {
                  clearInterval(typingTimer);
              } else {
                  time -= 1;
                  let timePad = time < 10 ? "0" + time : time; // zero padded
                  let minutes = Math.floor(timePad/60);
                  let second = Math.floor(timePad % 3600 % 60);
                  let showTime = minutes + ":" + ((second < 10) ? "0"+second : second);
                  $("#timer > span")[0].innerHTML = `${showTime}`;
                  segundos = 60 - second;
              }
          }, 1000);
      } else if (one == "0:00") {
          return false;
      }
      return true;
  }
  

  
  function calculateWPM(data) {
      let { seconds, correct, incorrect, total, typed } = data;
      let min = seconds / 60;
      let wpm = Math.ceil(typed / 5 - incorrect / min);
      //console.log("here i am " + wpm);
      let accuracy = Math.ceil(correct / total * 100);

      document.getElementById("accuracy").value = accuracy;
      document.getElementById("wpm").value = wpm
  
      if (wpm < 0) {
          wpm = 0;
      } // prevent negative wpm from incorrect words
  
      // template strings are pretty cool
      let results = `<ul id="results">
          <li>WPM: <span class="wpm-value">${wpm}</span></li>
          <li>Accuracy: <span class="wpm-value">${accuracy}%</span></li>
          <li id="results-stats">
          Total Words: <span>${total}</span> |
          Correct Words: <span>${correct}</span> |
          Incorrect Words: <span>${incorrect}</span> |
          Characters Typed: <span>${typed}</span>
          </li>
          </ul>`;
  
      $("#word-section")[0].innerHTML = results;
  
      // color code accuracy
      let wpmClass = $("li:nth-child(2) .wpm-value")[0].classList;
      if (accuracy > 80) {
          wpmClass.add("correct-word-c");
      } else {
          wpmClass.add("incorrect-word-c");
      }

      return wpm;
  }
  
    
  function fastWPM(data) {
      let { seconds, correct, incorrect, total, typed } = data;
      let min = segundos / 60;
      let wpm = Math.ceil(((typed / 5) - incorrect) / min);
      let accuracy = Math.ceil(correct / total * 100);
      document.getElementById("accuracy").value = accuracy;
      document.getElementById("wpm").value = wpm
      //console.log("resta ->" + (typed/5 - incorrect) + " tiempo->" + segundos + " wpm-> " + wpm);
      if (wpm < 0) {
          wpm = 0;
      } // prevent negative wpm from incorrect words
      return wpm;
  }
  
  var typed_char=0; //number of characters typed after a SPACE hit
  var delete_soon = false;
  var submitted_words = 0;
  
  function typingTest(e) {
      // Char:        Key Code:
      // <space>      32
      // <backspace>  8
      // <shift>      16
      // [A-Z]        65-90
      // [' "]        222
  
      // Get key code of current key pressed.
      e = e || window.event;
      let kcode = e.keyCode;
      let word = $("#typebox")[0];
      //console.log(word.value);
  
      // check if empty (starts with space)
      if (word.value.match(/^\s/g)) {
          word.value = "";
      } else {
          
          // Only score when timer is on.
          if (isTimer(wordData.seconds, timeInput)) {
              typed_char++;
              // <space> submits words****
              if (kcode == 32){
                  typed_char=0; // Reset to zero after a SPACE hit
                  let split =  word.value.split(" ");
                  let current_word = split[(split.length)-2];
                  submitWord(current_word);
                  clearLine(1); // get rid of old words
                  if (segundos>0)
                      document.getElementById("wpm").value = fastWPM(wordData);

              }
              else if (kcode == 8)
              {
                typed_char--;
                let split =  word.value.split(" ");
                let number_of_spaces = split.length-1;
                //console.log("number of spaces=>"+number_of_spaces+ " submitted words=>" +submitted_words+" word=>*" + word.value+" extract=>*"+split[split.length-1]);
                while (number_of_spaces<submitted_words)
                    {
                       clearLine(-1); // get rid of old words
                       goBack(word);
                       submitted_words--;
                    }
                wordData.typed = word.value.length; // -number of spaces, en caso de querer excluir los espacios
                }
              wordData.typed += 1; // count each valid character typed
              document.getElementById("count_typed").value = wordData.typed;
          } else {
              // Display typing test results.
              calculateWPM(wordData);
          }
      }

      
  }
  
  
  </script>
</body>